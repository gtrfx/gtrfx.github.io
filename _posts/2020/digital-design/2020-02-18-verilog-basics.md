---
title: "Verilog Basics: 별 거 없다"
tags: [verilog, basic]
layout: post
---

Verilog가 진작에 업계 표준이 되었는데, 학교 다닐 때는 쉽게 구할 수 있는 tool이 vhdl을 위한 거라 쳐다볼 일도 없었던 것 같다. 이 바닥 일은 사실 툴로 시작해서 툴로 끝나는 듯 하다. 돈과 사람을 때려박으면 결과가 나오는 그런 사업이다. 다만 돈이 좀 많이 들어간다는 게 문제이긴 하다만. 운까지 따라주면 상상을 초월하는 마진을 얻을 수 있으니까 (어떤 사업이 안 그러겠냐만).

이쪽 과목을 잘 가르치는 학교라고 알려진 곳도 사실 알고 보면 이런 툴과 개발 장비가 팍팍 보급되는 그런 학교/과/연구실이다. 아무리 책으로 열심히 파고 강의하고 머리털 쥐어 뜯어봐야 직접 해보지 않으면 아무 것도 되지 않는다.

Verilog은 어떻게 합니까? 의 질문은 그냥 간단하다. 이것은 그냥 모듈로 시작해서 모듈로 끝나는 것인데 시간 개념을 어떻게 생각하느냐의 차이만 있을 뿐이다. 말로 하면 그런가보다 하는데, 직접 툴을 가지고 일을 해보면 이게 말처럼 쉬운 게 아니로구나 하게 된다. 그래서 그런가 내가 아는 이쪽 사람들은 대개 말보다 행동으로 보여주는 사람들이다. 잘은 모르겠지만 사람의 말이 아닌 기계의 말을 주로 사용하게 되면 그것의 간결함과 명료함 때문에 사람의 말을 하기 싫어지는 게 아닐까 한다. 메일을 주고 받을 때도 그냥 기계의 말을 직접 써서 전달하면 대개는 몇 줄로 의사소통은 끝난다. 이것을 사람의 말로 환원시켜서 소통하는 경우 그 모호함과 감정의 은닉(?)되어있다고 해석되어질 부분이 많아서 무슨 소릴 하는 것인지 이해가 되지 않을 수도 있고 곡해하는 경우도 생긴다.

기계의 말을 할 줄 아는 사람들끼리 소통하고 기계와 소통하는 것까진 아주 좋은데, 문제는 사람의 언어만 구사할 줄 아는 사람들과 소통할 때다. 짧은 몇 마디에도 감정과 각종 비유를 뒤섞어놓은 말을 하는 사람들은 소통하기가 너무 힘들다. 대개 이 사람들은 소통시 발생한 에러도 마찬가지 방법으로 알려준다. 왜 사람의 언어가 가진 모호함을 이런 식으로 활용하는가? 

#### 기본 구조

본론으로 돌아와서 verilog는 다음과 같이 기술한다.

```
module module_name( arg0, arg1, .... )

...

endmodule
```

하나의 function을 보는 것 같다. 그러나 시간 개념의 차이점을 가지고 있다. 일부러 시간과 관련된 것을 표현하지 않으면 모든 statement는 동시에 실행되는 것이라고 보면 된다. 그리고 이렇게 작성해놓으면 가상의 공간에 하나의 instance 가 생겨나는 것이므로 주어진 조건이 성립되는 한 계속 실행 되는 것이다. 그래서 이것을 프로그래밍언어로 쓰면 (while(1) { ... }) 이 되는 것이다.

arg들의 type을 정하는 것은 "()" 안에 하든 밖에 하든 상관없다. type이란 것도 사실 간단해서 bit width가 얼마가 되는지와 wire인지 register (reg/logic)인지 입력(input)인지 출력(output)인지 혹은 user가 define한 pack인지 (struct쯤 해당한다고 보면 된다, 이게 bus라고 치면 bus가 된다).

#### 시간 개념

시간 개념이란 것은 사실 기본 전제가 동시에 항상 실행되는 것이라고 이해하면 된다. 말이 실행이지 statement를 기술함으로써 땜질(wired)이 되어버리는 것이다. 

```
module module_name( arg0, arg1, .... )

=== concurrent block ====

always @(...) begin

=== procedural block ====

end

endmodule
```

단 always ... 혹은 if ... 가 들어가는 경우엔 (둘다 다 조건문에 해당한다) 시간적인 개념이 달라붙게 된다. 즉, 이것을 실제로 구현하는 것은 납과 wire가 아니라 logic gate (FF)가 들어가야 되기 때문이다. 다시 말해 전기적으로 스위칭되고 전기적으로 읽혀지고 쓰여지는 것이라 시간 개념이 붙게 된다.

```
assign c = d;
```
라고 하면 사실상 c와 d는 wired 되어있다고 이해하면 된다. 

```
always @(posedge clk) begin
   c <= d;
end
```
라고 기술했다고 하면 clk이 positive edge일 때 d의 값이 c에 들어가게 된다. 항상 d의 state가 c의 state가 되는 것이 아니라 (wired 되어있는 것이 아니라) posedge clk일 때만 d의 상태가 c의 상태로 들어가게 된다. 그러하다 하더라도 begin, end 사이의 statement는 일부러 시간적인 delay ('#'로 표시되는)를 주지 않는 이상, 그 안의 위치에 상관없이 모두 동일한 시간에 진행되는 것이라고 보면 된다.

#### FSM (finite state machine)

만약에 순차적인 일을 수행하고자 한다고 하면 state를 알려주는 register를 하나 두고 그것에 맞춰서 'case' statement에 따라서 logic을 구성하면 된다. 사실 이것이 FSM (finite state machine)이 된다.

```
reg [10:0] global_state

...

case (global_state)
    11'd000: begin
       ...
       end
    11'd001: begin
        ...
        if (...) begin
            global_state <= 11'd033
        end
    end
    ...
    ...
end
```
이런 식이 되는 것이다. 말이 거창할 뿐이지, 그냥 시간에 맞춰서 어떤 일을 하겠다 하는 것과 같다. pipeline도 마찬가지로 이미 결정해놓은 자원을 일렬로 늘어놓고 처리해야 하는 일의 경우도 이런 식으로 처리하면 된다.

나머지는 tool이 다 알아서 해준다. 

#### ALU/RAM/ROM

이것은 내가 처한 상황에 따라 다르다. FPGA처럼 모두 다 되어있는 경우엔 합성하는 과정에서 이미 만들어져있는 (최적화되어있는), 혹은 각각의 라이브러리를 가지고 있는 경우에는 툴이 알아서 이것들을 쓰게끔 해주고 그렇지 않은 경우는 모두 자체의 방법론에 따라 합성하게 된다. 이 과정에서 general한 rule이 사용되게 될 것이므로 아까운 gate들이 마구마구 소모되게 될 것이다.

나머지는 모두 tool이 알아서 해준다. 제약조건 같은 것들은 툴에 맞춰서 업체에서 제공해준다. 개인 입장에선 FPGA를 쓸 수 밖에 없는 시스템이다. 회사의 경우는 각각의 부분별로 담당하는 전문가들이 있으니까 일반 로직을 설계하는 사람들은 주어진 spec에 따라서 RTL만 잘 마무리하면 되지만 말이다. 