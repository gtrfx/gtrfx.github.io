---
title: "System C/HLS 체험기: 첫 날"
tags: [systemc]
layout: post
---

아마도 여기에 관련된 글을 한참 쓰게 될 것 같다. 뭔가 배운 게 있으면 어떻게든 적어가면서 복습을 해야지 뭔가 배운 느낌이 나니까 말이다. 

#### 처음 느낌

system c에 대해서 막연히 들었을 때는 별도 컴파일러가 있거나 할 것 같지만, 그런 것은 없고 헤더와 소스파일 (그것은 어차피 컴파일되어 라이브러리의 형태로 달라붙게 된다) 뿐인데, 더 자세히 들여다보면 일종의 매크로 같은 것과 코딩하는 형식 같은 게 정해져있을 뿐이다. 

#### 뭐가 좋은가?

별 다른 것은 없고 어차피 verilog coding을 하려면 나름 툴이 갖춰져있어야 되는데 이것은 그냥 C 컴파일러 하나만 있으면 되니까 쉽게 일을 할 수가 있다. 그러니까 C 프로그램 짜듯이 RTL을 라이센스 달라는 툴 없이 만들고 테스트할 수 있다. 이 상태에서 대부분 개발을 하고, 그 결과물을 가져다가 HLS 툴에 붙여서 다음 과정으로 들어가면 된다.

#### 뭐가 다른가? 일반 C/C++과?

나처럼 취미로 관찰하는 입장에서는 RTL의 개념을 C/C++로 옮겨놓은 그런 모양새다. 

class definition은 모듈의 입출력 신호와 behavior를 기술하는 thread function들을 정의하고, 각각의 behavior는 thread 함수로 기술하게 된다. 그냥 딱 보면 verilog를 C로 써놓은 것 같은 느낌이 그냥 든다. C++의 형식을 빌어놓은 verilog라고 보면 될 것 같다. 그것을 좀 편하게 하려니까 macro 같은 것도 정의해놓고 말이다.

#### HLS 돌려보면 어떻게 되는 건가?

먼저 syntax를 확인해야 되니까 C 컴파일러가 먼저 돈다. 그 다음 그 프로젝트를 HLS 관련 툴들이 돌리면서 verilog를 생성하는데, 지원하는 여타의 툴들 (이를테면 ASIC으로 할 것인지 FPGA로 할 것인지)에 따라 결과물을 따로 써내고 또 이미 작성된 systemc를 rtl용으로 세분화 해놓은 c 파일도 생성해낸다. 그러니까 약간 하위 개념의 C/verilog 파일을 만들어낸 것이라고 보면 된다. 여기에 testbench code를 써넣으면 이렇게 만들어진 결과를 가지고 검증을 하게 되는 것 같은데 아주 간단한 모듈임에도 수행시간이 제법 걸리는 것을 보면 나름의 최적화를 하고 있다는 것을 알게 된다.

오늘이 첫날이라 constaint를 어떻게 주어야 하는지 몰라서 좀 황당한 결과가 나오긴 했는데, 결과 리포트를 보면 latency가 0이라고 나오는 것으로 봐서 물량을 최대한으로 사용했을 때의 설계 결과라 그런 것이구나 알 수 있다. 즉, 리소스 스케줄링이 잘 되었다면 latency는 좀 있겠지만 리소스(area/register)를 최소한으로 사용하면서도 좋은 결과가 나왔겠지 싶다. 

#### 최적화의 득과 실?

최적화라는 게 별 게 아니라 컴퓨터의 도움을 받아서 주어진 조건에서 적합한 결과물을 만들어내는 것이라고 본다. 사람이 작업하게 되면 별 다른 제한 사항을 두지 않더라도 (그동안의 경험을 토대로) 여러 가지 요소를 적당히 배려한 결과물이 나오게 되는 반면, 컴퓨터는 이것들을 명확하게 제시하지 않으면 전혀 엉뚱한 결과를 얻게 될 수도 있다.

최적화이라는 것이 연산 로직의 집합체를 스케줄러를 통해서 운영하는 모델을 가지고 일어난다는 것이다. 여기에 사람이 붙여주는 constraint에 따라서 연산로직의 자원을 더 쓰거나 아니면 덜쓰면서 최대한 재활용하거나 하는 식으로 굴러가게 되는 것이다. 다시 말해 시간 제약이 빡빡하다고 하면 연산 로직을 많이 사용하고 스케줄링 방법은 단순하게 갈 수 있는 반면, 시간 제약은 느슨하더라도 자원양에 제약을 가져가면 스케줄러가 빡시게 돌게 되어있는 식이 되는 것이다.

대개 사람이 디자인 할 때는 깊은 단계까지 파이프라인을 최적화하지 않고 개발자 스스로가 이해하기 쉽고 자원 스케줄링을 도식화하기 쉬운 방법으로 자원을 배분하게 되니까 자원의 낭비도 제법 생겨나게 되고 기대했던 것 보다 오버스펙으로 만들어낼 수도 있지만, 추후에 변경을 가한다거나 문제가 생겼을 때 디버깅하기에 상대적으로 유리한 모양새를 갖는다. 

대신 컴퓨터가 이 일을 수행하게 되면 연산 로직이란 것도 해당 문제를 해결할 때의 최적의 결과를 가져오는 요소만을 가지고 설계되고 그것들을 스케줄하는 과정 또한 아주 무자비하게 이루어지기 때문에 그 결과를 사람이 읽거나 해석하기엔 제법 어려움이 따르게 된다. 추후에 디버깅을 한다는 것은 상위 레벨 언어를 변경하여 재설계하지 않으면 안되니까 사후 뗌빵이라는 것은 정말 쉽지 않은 일이 된다. 

#### 이걸 협업과정에서 어떻게 사용하면 되는 것인가?

1차 과정에서 나온 RTL code를 보면 사람이 이해하기 쉬운 수준으로 쓰여져있다. 사실 system c가 verilog의 형식로 씌여져있는 것과 별로 다르지 않다. 그게 좀 더 아랫단계로 내려가면 resource scheduling 때문에 읽어내기 어려워진다. 따라서 생성된 verilog 결과물을 통째로 모듈화해서 넘기면 (constraint만 잘 설정되어있다면) 협업에는 별 문제가 없을 것으로 기대된다. 이 과정은 사실상 비 RTL 엔지니어가 RTL 엔지니어의 영역에 끼어드는 일이기도 하고 통합환경 혹은 자동화된 스크립트를 잘 쓰게 되면 C interface를 통해서 검증을 하는 영역까지 거들게 되는 것이라 분명히 효과가 있다고 본다. 더구나 microprocess나 DSP core가 아닌 이상엔 대부분 특정 분야의 특정 목적을 가진 가속기가 대부분이라 RTL 엔지니어가 그것을 이해하고 설계하기 보단 알고리즘 엔지니어가 RTL 관련 constraint를 파악하고 접근하는 것이 상대적으로 시간절약이 된다. 

