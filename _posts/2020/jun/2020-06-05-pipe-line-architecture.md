---
title: "파이프라인 아키텍쳐"
layout: post
tags: [pipeline architecture]
---

파이프라인 아키텍쳐라는 말이 전공자라도 관련없는 분야에서 일했다면 많이 들어는 봤는데 무슨 뜻인지는 잘 모르겠다 할 수 있겠다. 이거 뭐 CPU에 쓰이는 그런 거 아닙니까? 물어볼 수도 있고.

이거 아주 쉽게 말해서 그냥 공장의 컨베이어벨트 시스템 생각하면 된다. 다시 말하면 처리기를 직렬로 늘어놓은 것이다, 대개 이쯤까지도 이해를 한다. 그런데 그 장점이 무엇이냐에 대해서는 (알 필요가 없으니까 생각해 본 적도 없고 하니까) 물어보면 글쎄?? 하며 잘 모른겠단다.

언어라는 게 연상작용이란 게 있어서 파이프라인이란 말을 들으면 곧장 떠오르는 것은 송유관, 혹은 가스관 같은 것을 생각하는데, 그런 유체가 파이프를 빠져나가는 일을 디지털 회로의 파이프라인으로 연상하긴 쉽지가 않다. 

파이프라인 아키텍쳐의 장점은 초기 투입시 latency는 좀 있지만, 매우 빠르게 문제를 해결할 수 있는 방법 중에 하나다. 쉽게 생각해서 어떤 문제를 해결해야 할 때 이것을 매우 빠른 속도로 해결하려고 한다면 병렬화하는 방법이 있다고 하면 직렬화를 통해서도 해결할 수 있다는 것을 의미한다.

이걸 송유관으로 생각하면, 사실 유조차가 한탱크 가득 실어서 단위거리를 왕복하는 것 보다 훨씬 더 효율이 높다고 볼 수 있다 (비용을 고려하지 않는다면).물론 처음 보내는 기름은 먼 거리를 여행해야 되니 시간이 꽤 걸리게 되지만, 많은 양을 보낸다고 보면 사실 이 초기 시간 지연은 무시할 수 있는 수준이 된다.  

그냥 아주 상식적으로 생각해서, 공장에서 물건을 만드는데, 사람을 1명에서 10명으로 늘렸다고 치면 그것을 병렬로 늘어놓든 아니면 직렬로 늘어놓든 분명 생산량이 늘어날 것이라고 생각할 수 있을 것이다. 파이프라인은 자원을 직렬로 늘어놓은 것이다. 

무슨 말이냐면, 어떤 문제를 해결해주는 장치가 있다고 할 때, 동시에 N개의 문제를 해결하고자 한다면 그 장치를 N개 들여놓고 돌리면 된다고 생각할 수 있다. 이것을 흔히 병렬화 (parallelizing)했다고 한다.

따라서, M개의 문제를 N개의 병렬장치를 통해서 해결했다고 보면 M/N 의 단위시간동안 해결했다고 볼 수 있다. 따라서 시간의 효율측면에서 보면 N이 클수록 유리하고, M이 클 수록 불리하게 된다. 

만약 이것을 직렬화했다고 하면, 문제를 해결해주는 단계별로 나눠서 그 단계를 해결해주는 장치를 직렬로 늘어놓으면, 전체 문제해결 단계가 N 단계라고 하면, N개의 장치를 두었다고 볼 수 있다. 

만일, 한개의 장치로 그 문제를 해결한다고 보면 N 단계를 거쳐야 되니까 공정을 끝마치는데 모두 N x 공정해결시간이 들게 된다. 따라서, M개의 문제를 해결한다고 보면 M x N 단위시간이 들게 된다. 

대신 N개의 공정을 처리하는 장치를 단위별로 직렬로 늘어놓으면 (=파이프라인) 하나의 문제가 들어가서 해결되는데까지는 모두 N x 단위시간이 들게 되지만, 문제가 계속해서 들어가게 되면 초기의 문제해결시간에 들어가는 시간 (=latency)만 N x 단위시간이 되지만, 매 단위시간마다 문제가 해결되니까, 전체 소요시간은 들어간 문제의 수가 M개라고 보면 (M-1) + N이 된다. 따라서 M이 충분히 크면, 사실상 공정의 개수 N은 의미가 없어지고, 결과적으로 M개의 문제를 M개의 단위시간동안 해결했다고 볼 수 있게 된다.

따라서, 어떤 생산장치를 설계한다고 보면 단위 처리기의 배치와 그 수를 어떻게 놓아야 전체적인 효율이 최대화될 수 있는지는 간단하게 초중등과정의 산수만 할 줄 알아도 이해와 해결이 가능한 것이다. 

그런데, 그것을 상당히 어렵게 가르치는 곳이 대학교라는 곳이라고 볼 수 있다. 그 이유는 많은 시간을 소모해서 학위를 따고 교수가 되었으나, 알고 있는 것은 새로 들어온 신입생과 별 차이가 없다는 것을 드러내보이기 뭐했기 때문이 아닐까? 그래서 공부를 위한 공부가 되는 것이고, 강의는 지리 멸렬하고, 누구나 쉽게 이해할 수 있는 과정도 중고시절 학교에서 날리던 학생들도 빌빌 거리게 만들어버리는 것이다.

이것을 디지털 회로로 보면, 계산이 엄청나게 복잡한 문제인데, 이것을 1 clock에 해결했다고 하면 '이게 말이되나?' 싶지만, 역시나 처리기를 직렬로 많이 늘어놓으면 이게 가능한 이야기가 된다. 들어가는 데이터의 수가 얼마 되지 않는다면 1 clock에 해결되었다고 할 수 없지만, 입력되는 데이터의 수가 엄청나게 많다고 보면 사실상 1 clock에 해결되었다고 볼 수 있게 된다. 

이것을 컴퓨터 프로그램의 개념으로 보면, 복잡한 문제를 해결하는 프로그램이 모든 과정을 수행하는데 10분이 걸렸다 치면, 같은 프로그램을 수행하는 컴퓨터를 10대 놓는다고 치면 (병렬화) 개개의 문제가 해결되는데는 10분이 걸리지만 10개의 문제가 10분에 풀리게 되는 셈이니까 개당 문제 해결시간은 1분이 된다. 

이걸 직렬화(=파이프라이닝)하면, 프로그램을 10개의 부분으로 쪼개서 10개의 컴퓨터에 나눠돌리고 각각을 네트워크로 연결해서 순차적으로 처리시키면 첫번째 입력이 해결되서 결과로 나오는데까지는 10단계의 공정시간 (=10분)이 걸리지만, 개개의 부분이 통과하는데까진 1분밖에 안걸리게 되니까 입력이 많이 들어가면 들어갈 수록 개당 처리시간은 1분에 수렴하게 된다. 

따라서, 그냥 생각해볼 때 처리해야 할 문제의 개수가 별로 많지 않다면 같은 작업을 병렬로 돌리는 것이 분명히 유리하다. 

디지털회로에서 보면 어떤 문제를 하나의 ALU를 가지고 푼다고 보면 그 때 필요한 과정이 총 N단계라고 하면 M개의 문제를 풀 때 M x N 단계가 소요된다. 대신 각각의 과정을 해결하는 처리기를 모두 합성했다고 보면 N개의 단계를 구성하는 논리 회로가 직렬로 늘어지게 된다. 이 때는 M의 개수가 충분히 크면 개개의 처리 시간은 1단계를 지나는 데 들어가는 시간만큼만 소요된다고 볼 수 있게 되는 것이다. 

이걸 verilog로 어떻게 구현하느냐 생각하면, 쉽게 생각해서 매 계산단계마다 FF을 두고 매 clk마다 결과를 이동시키고 해야 되니까 골치아프게 되는 게 아닐까 하는데, verilog라는 언어의 장점이란 게 여기서 나타나게 된다.

이를테면 아래와 같이 쓰게 되면 곱셈기 2개, 덧셈기 1개가 합성된다. 또 여기서 a, b, d, e, g, h가 wire가 아닌 register로 정의하게 되면 매 stage의 결과를 담아두는 FF라고 생각할 수 있게 된다. c, f, i는 모두 wire로 정의된다.

```
assign c = a * b;
assign f = d * e;
assign i = g + h;
```

따라서, clk이 주어질 때마다 연산결과를 서로 다른 register로 이동시켜주면 pipeline으로 구현되는 것이다. 이를테면 아래와 같이 쓰게 되면 3단계의 연산이 필요한 복소수 곱셈 작업이 같은 연산 자원을 활용했다고 보면 3 clk이 필요하게 되지만, 3개의 연산기를 두게 되므로 복소수 연산을 1 clk에 해결하게 된다.
```
always @(posedge clk) begin

a <= in0;
b <= in1;

d <= in2;
e <= in3;

g <= c;
h <= f;
out0 <= i;
end
```

그냥 눈으로 보면 이게 어떻게 1 clk인가 할 수 있지만, 입력이 계속해서 들어오게 되면 개개의 처리결과는 평균적으로 1 clk에 해결된다고 볼 수 있다. 대놓고 이게 파이프라인이다 라고 하지 않을 뿐, 사실 마이크로 아키텍쳐로 보면 파이프라인드 아키텍쳐가 된다. 일단 연산기가 많이 붙고 register가 붙고 clk에 맞춰 움직이게 되면 pipelined가 된다. 그게 pipelined가 아니면 뭔가 문제가 있다고 봐야 한다.

여기서 질문이 하나 생기게 된다. 'pipelined 하지 말고 그냥 1 clk에 안되냐?' 답은 clk/gate delay에 따라 다르다. pipelined로 가면 개개의 연산요소들이 갖는 delay의 최대값을 clk을 결정하는데 쓸 수 있고, clock period가 그것보다 적당히 긴 정도면 별 문제없이 안정적으로 회로를 굴릴 수 있는데, 무리하게 한클럭에 결과를 뽑아내려고 하면 경우에 따라 원하지 않는 결과가 나올 수 있으니까 그렇다. 

다음은 일반적인 복잡도를 따지는 방법과 디지털회로의 처리 속도와의 관계가 어떠한지 생각해보기로 하자. 