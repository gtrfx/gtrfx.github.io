---
title: "Complex Class/Library/Multiplication..라이브러리를 믿지마라.."
---
# Complex Class/Library/Multiplication..라이브러리를 믿지마라..


살면서 여러 번 맞딱뜨리는 문제인데, 매번 실망했던 문제이기도 하다. 




미리 결론을 말하자면, complex library는 실행시간이 중요하지 않을 때만 사용하란 것이다. 뭔가 빠른 답을 얻고자 한다거나 짧은 시간에 많은 연산을 해야한다면 절대로 쓰지 마라. 적어도 개인적으로는 SSE 명령을 사용해서 complex 연산을 일반 실수 연산하듯 해낼 줄 알았는데, 전혀 그렇지 않다.




신기하게도 C/C++ library에서 제공하는 complex 연산은 이상하게도 이것을 풀어서 만들어놓은 것에 비해 매우 느리다. 추상화하면 할 수록 느려진다는 것도 알고 있긴 하지만 요새 library 및 compiler 최적화가 정점에 다다른 것으로 알고 있지만, 이것은 좀 심하다 싶다.




아래 그림을 좀 보자..




쉽게 complexlibrary를 써서 fast convolution을 실행했을 때의 속도다. 5120000개의 샘플 (116초에 해당)에 대해서 길이가 65536 (1초가 넘는 impulse)인 impulse response에 convolution을 취했을 때의 경우이다. 초기 setup부터 모두 다 고려해야되니 엄밀히 말해서 이게 순수한 연산을 하는데 들어간 시간은 아니니 자세히 따질 필요 없다.






![image](5e353d6425650b410c22456b1f105ba1.png)




약 7초가 소요되었음을 알 수 있다. 116초간의 데이터를 7초간에 모두 처리했으니 실시간 처리에는 아무런 문제가 없을 것으로 보여진다. 




그런데, profiling해 보면 complex library가 먹어대는 시간이 30%를 넘게 차지한다. 그래서 complex library을 쓰지 않고 모두 풀어서 곱셈/덧셈으로 나눠 계산했다.





![image](89076a22a9f73e7b67484f8d13bdbe35.png)




동일한 작업에 대한 런닝타임이 절반으로 나온다. 여러가지 환경에서 약간의 차이가 있을 수 있지만, 그것을 인정한다 하더라도 7초 걸릴 것이 약 3.6초로 나오는 것은 심각한 문제라 할 수 있다. 이를테면 하루 내내 돌아가야할 작업이라면 12시간이면 마칠 수 있단 얘기다. 불필요하게 complex library에서 까먹는 시간 때문에 말이다.





여타의 최적화 꼼수는 아직 적용하기도 전이다. 이 정도면 말 다한 것이다. 아무리 최적화 꼼수를 쓰더라도 complex library를 쓴 순간 무용지물화 되는 것이다.





