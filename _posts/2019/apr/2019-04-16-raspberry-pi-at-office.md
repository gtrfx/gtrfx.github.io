---
title: "사무실에서 라스베리파이의 용도"
tags: [raspberry pi, bridge, vpn]
---

라스베리파이의 장점은 뭐니뭐니해도 저전력으로 linux machine을 싸게 굴릴 수 있다는 것이라고 본다. 속도도 너무 느리지 않고 적당한 잡일을 시키기에 아주 안성맞춤이라고 본다. SoC 개발 속도로 봐서 이것보다 훨씬 더 빠른 AP를 가진 SBC (Small Board Computer)를 구할 수 있긴 한데 이렇게 안정적으로 돌아가는 Linux를 맞춤으로 구하기가 쉽지 않다. 다시 말해 이 정도로 안정된 주변 상황을 갖춘 물건이 없다는 것이다. 더 빠르고 더 성능 좋은 AP는 많은 반면.

본론으로 돌아와서 라스베리파이는 일반 리눅스 머신들이 하는 일을 다 시킬 수 있다. 급한 일이 아니면 특히나 더. 

그중에서 특히 쓸만한 일이 VPN 브릿지를 만들 수 있다는 것이다. 이런 걸 여기 적는 것이 바람직할지 아닐지는 모르지만, 외부에서 회사에 있는 내 컴퓨터들에게 명령을 내리려면 회사 VPN을 이용하는 게 맞는데, 이게 생각만큼 잘 동작하진 않는다. 그래서 내가 집에서 회사 VPN 서버에 접속하는 방법을 택하지 않고, 회사의 나의 라스베리파이가 내 집의 VPN 서버에 접속해서 브릿지 노릇을 하게 하면 된다. 물론 회사의 내 장비들은 회사 안의 나의 subnet 안에 몰아두고 말이다. 

갑자기 긴급한 일이 생겨서 회사에 나가야 하는 수고를 덜어준다. 물론 집에서 일을 할 때도 아주 편하다. 요샌 원격 접속이 OS 별로 아주 잘 되어있어서 속도만 보장되면 윈도우든 맥이든 Linux 머신이든 원격작업하는 일은 매우 쉽다. 이걸 피하려고 집에 PC를 가지고 다니는 것도 좀 웃긴다. 집에 (일반적으로 회사컴 보다 더 좋은) PC가 있는데 뭐하러 이걸 들고 왕복운동을 한단 말인가? 

물론 이 사실을 회사가 알게 되면 좀 골치 아파질 수 있는데, 그것은 내가 이 트래픽을 어떤 식으로 은닉하느냐에 따라 달라진다. 회사망에 일반적으로 통용되는 IP 혹은 ICMP 같은 패킷이 아닌 IPSEC 혹은 GRE/UDP 패킷 같은 것들을 흘리면 관리자가 대번에 알아차리게 되어있다. 그래서 그냥 일반적인 TCP 패킷에 얹어서 일반 트래픽인양 주고 받아야 한다. 즉, 고급사양의 VPN을 사용하기 보단 적당히 일반적인 트래픽을 가장해서 주고 받아야 된단 것이다. 포트 번호도 80이라든가 8080 등등 흔히 VPN으로 생각할 수 없는 것들로 하면 의심을 덜 받을 수 있다. 

물론 TCP 패킷을 보내기 위해서 TCP위에 터널링을 하는 것이 좋은 아이디어일 수는 없다. 그러나 가장 의심을 덜받고 소기의 목적을 달성할 수 있는 방법이기도 하다. 

ssh를 쓰자. SSH로 터널링을 하고 bridge 기능을 사용하면 내 책상과 우리 집 사이에 인터넷 직접 연결 파이프가 하나 놓이는 것과 같아진다. 물론 접속은 라스베리파이로 시킨다. 다른 장비들은 그 라스베리파이을 통해서 소통하게 하면 된다. 

ssh는 생각보다 기능이 엄청나게 많은 응용프로그램이다. 

ssh는 터널링을 지원하는데, 잘 알려진 대로 tcp 포트 단위로 터널링을 해주는 기능도 있지만, 아예 tunneling virtual interface로 대놓고 ip packet을 forwarding할 수 있게 한다. 무슨 말이냐고?

이를테면 집과 사무실에 독자적인 subnet이 있고 (이를테면 무선 공유기 같은 것으로 독립된 망을 말한다) 그 안에 라스베리파이가 각각 1개씩 있고 이 두 개의 라스베리파이 A/B가 연결되어있다고 치자. A가 강력한 방화벽 안에 들어있다고 하면 A가 B로 연결을 한다고 치자.

이 때, 나의 선택은 포트 1개를 찍어서 ssh로 뚫을 수도 있지만 아예 ssh라는 연결 통로를 이용해서 두 개의 망을 연결할 수 있다.

ssh의 -w 옵션이 거기에 쓰인다. 이를테면 라스베리파이 A에서

ssh -f -w 0:0 [라스베리파이B의 주소] true

한다고 하면 라스베리파이의 tap device 0으로부터 상대측 (라스베리파이 B)의 tap device 0으로 연결을 한다는 의미가 된다. tun device를 써야하니 상대방쪽으로 root로 login을 해야하기 때문에 /etc/ssh/sshd_config를 조정해서 root login을 허가해야 한다.

일단 접속이 되면

ifconfig tun0 어드레스1 어드레스2(gw) netmask .... up

해서 tun0를 활성화 시킨다. 어드레스 1은 해당 device에 붙는 주소고 어드레스 2는 gateway 주소가 되는데, 어차피 터널링 디바이스므로 내가 터널을 뚫는 곳의 터널 디바이스의 주소가 되어야 한다.

즉, A에서 10.10.10.1로 주소룰 붙이고 10.10.10.2를 gateway로 했다면 B는 10.10.10.2로 붙이고 gateway는 10.10.10.1로 해주면 된다. 서로 양방향으로 tunnel을 뚫은 것이 된다.

그 다음 내가 접속할 네트웍의 주소 대역을 해당 게이트웨이로 연결해주게끔 routing table을 넣는다.

route add -net 목적지네트웍/마스트 gw 게이트웨이주소(터널 디바이스 주소) tun0

일단 여기서 필요한 작업은 끝난다. 내가 서브넷을 공유기로 꾸리고 있다면 공유기에 routing table을 하나 추가해주면 공유기가 해당 주소 대역을 터널을 뚫어놓은 라스베리파이로 라우팅하게 해준다. 그럼 라스베리파이는 ssh 터널을 통해서 상대방 측의 라스베리파이에 접속하고 그 라스베리파이는 해당 패킷을 터널링 디바이스를 통해 포워드해서 목적지로 내보내준다. 물론 상대방 네트워크의 공유기에도 같은 맥락으로 라우팅 테이블을 하나 추가하면 양쪽의 네트워크가 ssh로 뚫리게 된다.

그런데 서브넷에서 저 건너편 네트워크에서 건너온 패킷을 유통시키려면 어쩔 수 없이 nat을 해줘야 한다. 

iptables -t nat -A POSTROUTING ! -o lo -j MASQUERADE

한 줄 더해주면 양쪽 서브넷의 디바이스들이 아무 문제 없이 ssh를 타고 양쪽을 자유롭게 넘나들 수 있다.

아쉽게도 나는 bonjour package을 forward하는 법은 잘 모른다. 어쩔 수 없이 지방방송을 켜줘야 한다.
