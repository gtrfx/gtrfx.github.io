---
title: "오늘의 학습 내용(4/16/2025)..."
tags: [study]
layout: post
author: "Keith"
---

**RISC-V**:    
openSource CPU로 공개가 되어있는데 어떤 건 verilog, 어떤 건 chisel로 쓰여있어서 chisel을 또 알아봐야 되나 보고 있음.

**Chisel**:    
설치해보고 몇 가지 예제를 해봤는데, 아직 개념이 잘 와닿지가 않음. 장점은 하드웨어적인 구현 여부에 대해서 잘 모르는 사람이라고 하더라도 상위 언어 쓰듯이 설계를 하면 신기하게도 sv를 만들어 줌.   
문제는 뭔가 익숙하지 않은 scala라는 언어를 사용해서 기술한다는 것인데, 어차피 형식의 문제만 있을 뿐 뭐 그다지 진입장벽이 높진 않아 보임.

그런데, 너무 추상적인 이유로 verilog에 1:1 대응이 되지 않고 엉뚱한 결과가 나오기도 한다. 사실 verilog도 어떻게 작성했느냐에 따라서 합성했을 때의 결과가 매우 다양해지는데, 이렇게 추상적으로 기술하는 경우에 그 결과가 쓸만한 것일지 아닐지 장담할 수 없다.   
예제로 fifo를 만들어봤는데 내부 메모리를 vector로 처리하게 되는 게 일반적인데, 이 때 verilog로 변환을 하면 array를 쓰지 않고 각각을 모두 register로 선언해서 처리해버리는 이유로
vivado에서 합성시켜보면 RAM 대신 값비싼 FF를 엄청나게 써버리는 결과가 나온다.    
물론 verilog로 작성하면 합성툴이 알아서 RAM을 써서 매우 깔끔하게 나온다. 

이런 게 있다는 것을 아는 정도로만 하면 될 것 같다. clk이나 reset을 정교하게 다루고 싶으면 뭔가 꼼수를 부려야 되는 문제도 보였다.

verilog가 매우 꼼꼼한 반면 규모가 커지면 대단한 노가다를 해야 되는 문제는 있다. 아주 쫌스러운 것을 가지고 물고 늘어질 수도 있고 (왜냐면 그런 것 하나에 합성한 결과가 크게 달라질 수 있으니까), 그런 게 계속 쌓이면 노가다에 의한 부담이 꽤나 클테니까.

