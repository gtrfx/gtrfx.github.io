---
title: "CGRA(Course Grain Reconfigurable Architecture)..."
tags: [mlir]
layout: post
author: "Keith"
published: false
---

세상 흐름에 워낙 둔해서 그런지, 문득 눈을 떠보니 이것저것 새롭게 알아가는 것들이 참 기쁘게 느껴진다.

CGRA라는 개념은 예전부터 있었던 것이지만, 요즘 들어 특히 이 이름으로 다양한 논문들이 쏟아져 나오는 걸 보니 새삼 새롭게 다가온다.

생각해보면 나는 이런 구조의 프로세서에 꽤 자주 노출되어 있었기 때문에, 오히려 그다지 관심을 갖지 않았던 것 같기도 하다.
내가 이런 프로세서들에 대해 갖고 있던 경험은 대략 이렇다:
- 2000년대 초반에도 이런 아이디어/제품들은 꽤나 많았다. 구조는 훌륭한데, 최적화를 못 해서, 아니면 사용하기 너무 어려워서 대부분 망했다.
- 그나마 소수의 망하지 않은 경우는 돈과 사람이 많이 투입된 경우였고, 그래도 여전히 쉽지 않았다.

그런데 최근에는 MLIR과 HLS 알고리즘이 결합되면서, 원가 측면에서 획기적인 돌파구가 열리고 있는 듯하다.

이전처럼 소프트웨어 따로, 하드웨어 따로 설계하면서 발생하던 비효율적인 요소들을 통합해, 더 복잡하고 연산량이 많은 문제들 — 예를 들면 transformer나 대형 neural network와 같은 — 를 훨씬 효율적으로 풀어가려는 방향이다. 일명 H/W + S/W co-design이라고 할 수 있다.

특히 눈에 띄는 점은, 프로세서 아키텍처가 더 이상 고전적인 방식—ALU 몇 개를 나열해서 돌리는 정도—에 머무르지 않는다는 것이다.
예를 들어, vector ALU에 register file과 local memory가 붙은 덩어리를 격자 구조로 이어붙이고, 이를 또 다른 컨트롤러가 제어하는 구조라든가, GEMV 유닛과 vector ALU로 구성된 블록들을 단순한 컨트롤러가 파이프라인으로 구동시키는 방식처럼 다양한 형태들이 등장하고 있다.
이런 다양한 구조들을 통합적으로 설계하고, 유지, 보수, 확장이 용이한 방식으로 가져가려는 시도들이 눈에 띈다.

어떤 이름을 붙이든 간에, 이런 시도들은 “전망이 있다”, “의미 있다”는 말보다 그냥 “재밌다”고 표현하는 편이 더 어울리는 것 같다. 적어도 나에겐 충분히 도전해보고 싶은 마음이 들 만큼 흥미롭다.

MLIR 상에서는 적용 가능한 최적화가 제한적일 수 있지만, 그만큼 고도로 개념화된 언어 표현을 제공한다. 이를 통해 S/W로 실행되는 부분(예: RISC-V 상의 코드)과 H/W로 구현되어야 하는 부분(예: CIRCT 기반의 HLS)을 동시에 기술할 수 있다.
custom dialect를 정의하면, backend에서 이를 분리해 하나는 RTL 설계로, 다른 하나는 LLVM을 거쳐 RISC-V나 DSP 등에서 실행 가능한 코드로 내려보낼 수 있다.

즉, 아주 상위 수준의 알고리즘이나 개념을 RTL과 실행 가능한 바이너리 코드로 한 번에 연결할 수 있게 되는 셈이다.
물론 전통적인 방식에 익숙한 입장에선, 이런 방법론이 이론적으로는 훌륭하지만 실무에서는 간단치 않다거나, 실물이 없는 공상에 불과하다고 여길 수도 있다.
하지만 이미 이 방법론으로 만들어진 결과물들이 실제로 실무에 잘 적용되고 있는 걸 보면, 점차 업계 표준으로 자리잡아 가고 있다는 생각이 든다.