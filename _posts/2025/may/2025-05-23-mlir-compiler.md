---
title: "mlir compiler..."
tags: [life]
layout: post
author: "Keith"
published: false
---

어쩌다보니 이 분야까지 연결이 되었다. 예전에 하던 일에 맞물려서. 
예전에 하던 일은 뭐랄까 주먹구구식이랄까? MLIR/LLVM과 같이 좋은 도구를 활용할 방법을 생각할 겨를도 없어서
아주 급조한 플랫폼을 만들고 그 위에서 작업을 했는데, 덕택에 한명이 고생하면 될 일을 대 여섯명이 한꺼번에 고생하게 만들었다고 해야할 것 같다. 그래도 다행스럽게 잘 돌아가는 칩이 나왔으니 다행이지만.

내가 MLIR을 보고 든 생각은 이거다.

LLVM은 (low level이라 명명된 건 아니지만) IR이 말 그대로 low-level이라 표현할 수 없는 것을 다양한 레벨(multi-level)으로 확장해 놓은 것이랄까?

MLIR만 잘 쓸 수 있어도 일반적인 CPU 구조를 위한 LLVM으로의 lowering이 가능할 뿐 아니라, 커스텀 IR(Custom IR)을 잘 정의해서 쓰면 다른 아키텍처를 채택한 프로세서에도 적용할 수 있다는 거다.

그러니까 LLVM이 가지고 있는 모든 자원은 충분히 활용해서 IR 수준에서의 이익은 다 챙기고, 나머지는 backend에서 customized 프로세서를 위한 scheduling이나 optimization를 해서 최종 binary를 만들어낼 수 있다는 거다.

백엔드를 잘 짜놓으면 HLS(High-Level Synthesis)에서 얻을 수 있는 수준의 report도 작성할 수 있고, 개발중인 프로세서라도 백엔드가 돌아가는 걸 보면서 어디를 어떻게 자르고 붙여야 할지에 대한 아이디어까지 얻을 수 있다는 거다.

그것을 위해서는 LLVM의 유틸리티 일부를 변경해서 나를 위한 다이얼렉트(dialect)를 처리할 수 있게 만든다거나, 혹은 LLVM 수준에서 simulation을 해서 중간 결과를 검증할 수도 있다. 이 과정에서 DPI-C라든가 고객의 S/W 시뮬레이션을 위한 c model은 자동으로 만들어진다. 꽤나 최적화된 형태로. 그러니까 pre-silicon 상태에서 모든 과정을 검증할 수 있게 되는 거다. Backend의 도움을 받게 되면 cycle accurate한 결과도 얻을 수 있게 된다.

쉽게 말해서 기존의 하드웨어+소프트웨어 개발, 그러니까 열심히 모여서 회의해서 얻어낸 안을 바탕으로 매우 근본 없이 빨리빨리 만들어서 스택을 쌓아 올려버림으로써 많은 자원을 소보하는 방법이 아닌, 검증된 방법론을 잘 적용해서 DSL을 이용하여 곧바로 H/W (data path + FSM) prototype과 S/W (firmware 내지는 fixed binary, 개발용 산물 c model/rtl level model)을 자동으로 만들어 내는 거다.

이런 backend를 만드려면 다음이 필요할 것이다.
- 계층적 설계: 백엔드를 하드웨어 독립적인 부분과 종속적인 부분으로 명확히 분리한다.
- TableGen 중심 개발: TableGen을 적극적으로 사용하여 명령어 집합, 레지스터 등 하드웨어 특성을 선언적으로 정의하고 자동 생성된 코드를 활용한다.
- LLVM 유틸리티 재사용: LLVM이 제공하는 타겟 독립적인 코드 생성 및 최적화 유틸리티를 최대한 활용한다.
- 확장성 고려: 새로운 하드웨어 기능이나 최적화를 쉽게 추가할 수 있도록 모듈화된 설계를 지향한다.
- 하드웨어 모델링: TargetMachine 및 TargetTransformInfo를 통해 하드웨어의 추상적인 특성을 LLVM에 반영한다.
- 시뮬레이션 기반 검증: JIT 또는 외부 시뮬레이터와의 연동을 통해 하드웨어 없이도 백엔드의 정확성과 성능을 검증한다.

일부는 실현되었고 또 많은 이들이 이런 방법론을 택하여 프로젝트를 진행 중이라고 한다. 아예 이런 방향으로 통합 개발툴을 만들려고 하는 이들도 있을 수 있을 거다.

어찌보면 matlab과 같은 플랫폼에서 해오던 일을 하겠다는 것으로 보일 수도 있다. matlab도 같은 시도로 S/W + H/W의 통합개발을 하려고 하는지도 모르고.